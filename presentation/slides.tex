\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{Madrid}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{beaver} % or try albatross, beaver, crane, ...
  \usefonttheme{serif}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{algorithm2e}
\usepackage{graphicx}
\lstset
{
    language=[LaTeX]TeX,
    breaklines=true,
    basicstyle=\tt\scriptsize,
    %commentstyle=\color{green}
    keywordstyle=\color{blue},
    %stringstyle=\color{black}
    identifierstyle=\color{magenta},
}

\title[CS396]{Auto Scaling of Key Value stores}
\author{Raghukul Raman}
\institute{IIT Kanpur}
\date{\today}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% Uncomment these lines for an automatically generated outline.
\begin{frame}{Outline}
  \tableofcontents
\end{frame}

\section{Abstract}

\begin{frame}{Aim}
    \begin{itemize}
        \item Design a system to collect real-time statistics on cluster-based system.
        \item Collect statistics for different queries on different scaling configurations
            and try to find possible bottlenecks in the system.
        \item Providing an auto-scaling solution for key
                value stores. 
    \end{itemize}
\end{frame}

\section{Introduction}


\begin{frame}{Key Value Stores}
    \begin{itemize}
        \item Data is organized in just two columns - a \textbf{key}, and a \textbf{value}.
        
        \item Actual data is value - can be object, keys are used to index these data objects.
        
        \item Satisfy \textbf{BASE} property.
            
            \begin{itemize}
                \item Basically Available
                
                \item Soft state
                
                \item Eventually consistent
            \end{itemize}
        
        \item \textbf{CAP} theorem
            \begin{itemize}
                
                \item Consistency
                
                \item Availability
                
                \item Partition tolerance
            \end{itemize}
       
        \item Fall into CP category.
        
        \item Mostly In-memory - extremely fast compared to traditional DBs.
    \end{itemize}
\end{frame}

\begin{frame}{Scalability}
    \begin{itemize}
        
        \item \textit{Def:} Property of a system to handle a growing amount of work by adding resources
            to the system[Bondi, Andre - 2000].
        
        \item Two variants:
            \begin{itemize}
                
                \item \textbf{Vertical Scaling:} Increasing the resources in the
                        server which we are currently using, i.e increase the amount of memory, CPU, etc.
                
                \item \textbf{Horizontal Scaling:} Increasing the number of servers (instances).
            \end{itemize}
        
        \item Benefits of horizontal scaling:
            \begin{itemize}
                
                \item Make the system fault tolerant.
                
                \item Downtime.
            \end{itemize}
        
        \item Several load balancing schemes are used in horizontal scaling.
    \end{itemize}
\end{frame}


\begin{frame}{Auto Scaling}
\begin{itemize}
    
    \item Implemented in four phases of the MAPE loop:
        \begin{itemize}
            
            \item Monitoring
            \item Analysis
            \item Planning
            \item Execution
        \end{itemize}
    \item In this project, we aim to work on the monitor and analysis phase.
    \item Why AutoScaling?
        \begin{itemize}
            \item To prevent overprovisioning.
        \end{itemize}
\end{itemize}
\end{frame}


\begin{frame}{Redis}
    \begin{itemize}
        \item Developed by Salvatore Sanfilippo(\textit{antirez}).
        \item Open source, in-memory data structure store, used as a database, cache and message broker.
        \item Supports other data structures like strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs.
        \item Built-in support for replication, on-disk persistence and automated partitioning with Redis cluster.
        \item Master-slave asynchronous replication.
        \item Transaction, expiration time (BigTable).
    \end{itemize}
\end{frame}

\begin{frame}{Redis Cluster}
    \begin{itemize}
        \item Collection of redis nodes
            \begin{itemize}
                \item Able to communicate among themselves.
                \item Able to respond to requests collectively.
            \end{itemize}
        \item Data is automatically sharded across multiple Redis nodes.
        \item Every redis node require 2 ports:
            \begin{itemize}
                \item The lower one is used to serve clients.
                \item Other used for Cluster Bus (node-to-node communication).
            \end{itemize}
        \item CRC16 hashing system - $16384$ hash slots.
        \item Each cluster node is responsible for a subset of hash slots.
        \item Hash tags.
        \item After cluster meet, every node contains node - hash slot mapping.
    \end{itemize}
\end{frame}

\begin{frame}{Resharding}
\begin{itemize}
    \item Redis Cluster supports the ability to add and remove nodes while the cluster is running.
    \item Same basic mechanism can be used in order to rebalance the cluster, add or remove nodes.
    \item Moving hash slots through Cluster Bus.
    \item No down time - with the help of MOVED Error.
\end{itemize}
\end{frame}

\begin{frame}{Redirection}
\begin{itemize}
    \item Client knows nothing - can send request to any node.
    \item On receiving a request:
        \begin{itemize}
            \item Return the value if serves that hash slot.
            \item MOVED error, if not served.
        \end{itemize}
    \item MOVED error response also contain IP:PORT of node serving that hash slot.
    \item Still is an overhead.
\end{itemize}
\end{frame}


\begin{frame}{Partitioning}
\begin{itemize}
    \item The way how we shard data among different nodes of redis cluster.
    \item \textbf{Client side partitioning:} redis clients select the node to which read/write request need to be made.
    \item \textbf{Proxy assisted partitioning:} client sends request to a proxy,
        which analyzes the request and forwards it to the correct node.
    \item \textbf{Query Routing:} can send request to any node, and the node
        will forward our request to the desired correct node.
    \item Examples: Jedis, Twemproxy, Redis Cluster. 
\end{itemize}
\end{frame}

\begin{frame}{Twemproxy}
\begin{itemize}
    \item Proxy assisted partitioning implementation.
    \item It maintains \textbf{persistent} server connections.
    \item Shard data automatically across multiple servers, keeps copy of node configurations.
    \item Not a single point of failure.
    \item Stats monitoring port.
\end{itemize}
\end{frame}

% Introduction section ends here.
\section{Experiments}

\begin{frame}{Experiments}
\begin{itemize}
    \item Collecting stats - by limiting resources.
    \item Generate random strings of length 64 - mimic SHA2.
    \item Tests based on get/set commands.
    \item Resource limitation enforced using Docker.
\end{itemize}
\end{frame}


\begin{frame}
    \includegraphics[width=\textwidth]{fig1.eps}
\end{frame}


\begin{frame}
    \includegraphics[width=\textwidth]{fig2.eps}
\end{frame}


\begin{frame}
    \includegraphics[width=\textwidth]{fig3.eps}
\end{frame}

\begin{frame}
\begin{center}
    \includegraphics[width=0.8\textwidth]{fig4.eps}
\end{center}
    \begin{itemize}
        \item fractional CPUs?
    \end{itemize}
\end{frame}

\begin{frame}
    \includegraphics[width=\textwidth]{fig5.eps}
\end{frame}
    
\begin{frame}
    \includegraphics[width=\textwidth]{fig6.eps}
\end{frame}

\begin{frame}
    \includegraphics[width=\textwidth]{fig7.eps}
\end{frame}

\begin{frame}
    \includegraphics[width=\textwidth]{fig8.eps}
\end{frame}

\section{Current Picture}

\begin{frame}{Machine Learning based solutions}
\begin{itemize}
    \item \textit{Auto-Scaling Network Resources using Machine Learning to Improve QoS and Reduce Cost} arxiv-1808.02975
    \item Measured network traffic load to dynamically react to traffic changes.
    \item A classification problem.
    \item This ML classifier learns from past network scaling decisions and seasonal/spatial
            behavior of network traffic load to generate scaling decisions ahead of time. 
    \item Models used:
        \begin{itemize}
                \item Reduced Error Pruning Tree.
                \item Decision Table.
                \item Multi-Layer Perceptron.
                \item DNNs.
        \end{itemize}
    \item Features used:  startup time, resource utilization factor, etc.
\end{itemize}
\end{frame}

\begin{frame}{Static metric based approach}
    \begin{itemize}
        \item \textit{Containers Orchestration with Cost-Efficient Autoscaling in Cloud Computing Environments - arxiv:1812.00300}
        \item Simple Autoscaler.
            \begin{itemize}
                \item Elapsed time since last instance launched $>=$ provisioning\_interval
            \end{itemize}
        \item Single Instance Binding Autoscaler.
            \begin{itemize}
                \item Multiple requests to autoscale triggered by the same unschedulable pod may be invoked.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Performace models}
    \begin{itemize}
        \item \textit{Automatic configuration and scaling of stream processing pipelines - arxiv:1812.09442}
        \item Precise performance models can be automatically
learned for distributed stream processing systems
that can predict the execution performance of a job
even before deployment.
    \item These models can be
used to optimally schedule logically specified jobs onto
available physical hardware.

    \item These models and
the derived execution schedules can be refined online to
dynamically adapt to unpredictable changes in the runtime
environment or auto-scale with variations in job
load.
    \end{itemize}
\end{frame}


\section{Further works}
\begin{frame}{Further Works}
    \begin{itemize}
        \item Implement dynamic scaling feature in Twemproxy.
        \item Add a service on top of Twemproxy to apply scaling logic (based on statistics received from Twem).

        \item Test some state of the art machine learning algorithms like Meta learning, Siamese nets, etc.
    \end{itemize}
\end{frame}

\begin{frame}
    \begin{center}
    \Huge{Thank You!}
    \end{center}
    \end{frame}



\end{document}
